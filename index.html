<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Лабиринт</title>
    <style>
        /* Стилизация тела страницы для центрирования и заполнения окна */
        body {
            margin: 0;
            padding: 0; 
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw; 
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        /* Контейнер игры: содержит холст и интерфейс, адаптивный размер */
        #game-container {
            position: relative;
            width: 90vw;
            max-width: 600px;
            height: 90vw;
            max-height: 600px;
            aspect-ratio: 1 / 1; /* Фикс для квадратной формы */
        }
        /* Стили холста: заполняет контейнер, добавляет рамку */
        canvas {
            width: 100% !important;
            height: 100% !important;
            border: 4px solid #333; /* Толще рамка для красоты */
            border-radius: 15px; /* Больше скругление */
            box-shadow: 0 0 30px rgba(0,0,0,0.4);
            background-color: #000;
        }
        /* Интерфейс: отображает счет, время и т.д. поверх холста */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 3px black; /* Улучшает читаемость на темном фоне */
        }
        /* Стили меню: центрированная панель для настроек игры */
#menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #000000; /* Полностью чёрный, без прозрачности */
    padding: 60px; /* Больше отступов — меню стало выше и шире */
    border-radius: 30px;
    color: white;
    text-align: center;
    width: 85%;
    max-width: 600px;
    min-height: 80vh; /* Занимает больше экрана по высоте */
    z-index: 100;
    box-shadow: 0 0 60px rgba(0,0,0,0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
}
        /* Стили для полей ввода, выбора и кнопок в меню */
#menu button, #menu input, #menu select {
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    border-radius: 10px;
    border: none;
    font-size: 18px;
}
#menu h3 {
    margin-top: 30px;
}
#menu h2 {
    margin-bottom: 30px;
    font-size: 32px;
}

#main-game-menu { display: none; }

        /* Метки в меню: жирные и с отступом для ясности */
        #menu label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }
        /* Панель обучения: скрыта по умолчанию, центрирована для инструкций */
        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
            display: none;
        }
        /* Анимация пульсации: легкое масштабирование для визуального эффекта */
        .animate-pulse {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        /* Адаптивный дизайн: корректировка для маленьких экранов */
        @media (max-width: 600px) {
            #game-container {
                width: 95vw; /* Шире для маленьких экранов */
            }
            #menu, #tutorial {
                width: 80%;
                font-size: 14px; /* Меньший шрифт для мобильных устройств */
            }
            #menu input, #menu select, #menu button {
                width: 90%; /* Полная ширина для удобства на мобильных устройств */
            }
        }

        
        #settings-section, #leaderboard-section { display: none; }
        
        .tab-content {
    display: none;  
}
#settings-tab, #leaderboard-tab { display: none; }
#auth-tab { display: block; }
button { padding: 10px; margin: 5px; width: 80%; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; }
input, select { padding: 10px; margin: 10px; }
    </style>
</head>
<body onload="updateAuthUI(); loadLeaderboard();">
    <div id="game-container">
        <div id="ui"></div> <!-- Область интерфейса для счета, времени, имени игрока, FPS -->
<div id="menu">
    <h2>Игра Лабиринт</h2>
    
    <!-- Стартовое меню (только при первом запуске или после выхода) -->
    <div id="start-menu">
        <button onclick="showAuth()">Вход / Регистрация</button>
        <button onclick="playAsGuest()">Играть как гость</button>
    </div>
    
    <!-- Панель авторизации (показывается по кнопке) -->
    <div id="auth-panel" style="display: none;">
        <h3>Регистрация</h3>
        <input type="text" id="reg-username" placeholder="Имя пользователя">
        <input type="password" id="reg-password" placeholder="Пароль">
        <button onclick="register()">Зарегистрироваться</button>
        
        <h3>Вход</h3>
        <input type="text" id="login-username" placeholder="Имя пользователя">
        <input type="password" id="login-password" placeholder="Пароль">
        <button onclick="login()">Войти</button>
        
        <p id="auth-message" style="color: red;"></p>
        <button onclick="backToStart()">Назад</button>
    </div>
    
    <!-- Главное игровое меню (после входа или гостя) -->
<div id="main-game-menu" style="display: none;">
    <div id="welcome-message" style="margin-bottom: 30px; font-weight: bold; font-size: 24px;">
        Привет, <span id="username-display"></span>!
        <div style="margin-top: 10px;">
            <button onclick="changeAccount()">Сменить аккаунт</button>
            <button onclick="logout()">Выйти</button>
        </div>
    </div>
     
    <button onclick="showProfile()">Профиль</button>
    <button onclick="showFriends()">Друзья</button>
    <button onclick="showSettings()">Настройки</button>
    <button onclick="showLeaderboard()">Лидерборд</button>
    <button onclick="startNewGame()">Начать новую игру</button>
    <button onclick="continueGame()">Продолжить игру</button>
</div>
    
<!-- Панель профиля -->
<div id="profile-panel" style="display: none;">
    <h3>Ваш профиль</h3>
    
    <div style="text-align: center; margin-bottom: 20px;">
        <img id="profile-avatar" src="" alt="Аватар" style="width: 150px; height: 150px; border-radius: 50%; object-fit: cover; border: 4px solid white;">
        <p>Текущее имя: <strong id="profile-username"></strong></p>
    </div>
    
    <label for="profile-bio">Биография</label>
    <textarea id="profile-bio" placeholder="Расскажите о себе" style="width: 100%; height: 100px; padding: 10px;"></textarea>
    
    <label for="profile-dob">Дата рождения</label>
    <input type="date" id="profile-dob">
    
    <label for="profile-avatar-input">Новый аватар</label>
    <input type="file" id="profile-avatar-input" accept="image/*">
    
    <button onclick="saveProfile()">Сохранить профиль</button>
    <p id="profile-message" style="color: red; margin-top: 10px;"></p>
    
    <button onclick="backToMainMenu()">Назад</button>
</div>

<!-- Панель друзей -->
<div id="friends-panel" style="display: none;">
    <h3>Друзья и заявки</h3>
    
    <!-- Добавление друга (заявка) -->
    <div style="margin-bottom: 30px;">
        <input type="text" id="friend-username" placeholder="Username друга">
        <button onclick="sendFriendRequest()">Отправить заявку</button>
        <p id="friends-message" style="color: yellow; margin-top: 10px;"></p>
    </div>
    
    <!-- Входящие заявки -->
    <h4>Входящие заявки</h4>
    <div id="incoming-requests-list"></div>
    
    <!-- Список друзей -->
    <h4>Мои друзья</h4>
    <div id="friends-list"></div>
    
    <br>
    <button onclick="backToMainMenu()">Назад</button>
</div>

    <!-- Панель настроек -->
    <div id="settings-panel" style="display: none;">
        <h3>Настройки</h3>
        <label>Сложность</label>
        <select id="difficulty">
            <option value="easy">Легко (10x10)</option>
            <option value="medium">Нормально (15x15)</option>
            <option value="hard">Тяжело (20x20)</option>
        </select>
        
        <label>Цвет шарика</label>
        <select id="ballColor">
            <option value="#FF0000">Красный</option>
            <option value="#0000FF">Синий</option>
            <option value="#00FF00">Зелёный</option>
        </select>
        
        <button onclick="resetGameProgress()">Сбросить прогресс</button>
        <button onclick="backToMainMenu()" style="width: 100%; padding: 15px; margin-top: 20px;">Назад</button>
    </div>
    
    <!-- Панель лидерборда -->
    <div id="leaderboard-panel" style="display: none;">
        <h3>Таблица лидеров</h3>
        <button onclick="loadLeaderboard()">Обновить</button>
        <div id="leaderboard-list" style="margin-top: 20px;"></div>
        <button onclick="backToMainMenu()" style="width: 100%; padding: 15px; margin-top: 20px;">Назад</button>
    </div>
</div>

<div id="tutorial" style="display:none;">
    <p id="tutorial-text"></p>
    <button onclick="nextTutorial()">Далее</button>
</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script> <!-- p5.js для работы с холстом и рисования -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script> <!-- Howler.js для работы со звуком -->
    <script>
        // Глобальные переменные для состояния игры и объектов
        let maze, player, goal, cellSize, score, timer, gameState, difficulty, playerName;
        const API_URL = 'http://127.0.0.1:8001/api';  // Если твой сервер на порту 8000 — замени 8001 на 8000
        let accessToken = localStorage.getItem('accessToken') || null;
        let currentUser = localStorage.getItem('currentUser') || null;
        let gameWon = false;  // Флаг для защиты от повторного сохранения (рекомендую)
        let tutorialStep = 0; // Отслеживает текущий шаг обучения
        let easterEgg = { x: 0, y: 0, found: false }; // Скрытый бонусный объект
        let bgMusic, winSound, easterSound, startSound; // Звуковые объекты
        let lastTime = 0; // Для вычисления времени между кадрами
        let frameCount = 0; // Счетчик кадров для расчета FPS
        let lastFpsTime = 0; // Метка времени для обновления FPS
        let fps = 0; // Кадры в секунду для отображения
        let hasActiveSave = false; // Флаг: есть ли сохранённая незавершённая игра
        let savedState = null; // Для хранения состояния локально (для гостей)
        let keys = {}; // Отслеживает нажатые клавиши
        let velocity = { x: 0, y: 0 }; // Скорость движения игрока
        let mouseControl = { active: false, targetX: 0, targetY: 0 }; // Состояние управления мышью
        const SPEED = 6; // Базовая скорость движения игрока
        const ACCELERATION = 25; // Скорость изменения скорости
        const FRICTION = 15; // Замедляет движение игрока
        let lastTimerUpdate = 0; // Метка времени для обновления таймера
        
        // Загрузка звуковых файлов с помощью Howler.js
        function loadSounds() {
            try {
                bgMusic = new Howl({
                    src: ['sound/fon.mp3'], // Фоновая музыка
                    loop: true, // Зациклена для непрерывного воспроизведения
                    volume: 0.3,
                    onload: () => console.log('Фоновый звук загружен успешно'),
                    onloaderror: (id, error) => console.error('Ошибка загрузки фонового звука:', error),
                    onplayerror: (id, error) => console.error('Ошибка воспроизведения фонового звука:', error)
                });
                winSound = new Howl({
                    src: ['sound/finish.mp3'], // Звук победы
                    onload: () => console.log('Звук победы загружен успешно'),
                    onloaderror: (id, error) => console.error('Ошибка загрузки звука победы:', error),
                    onplayerror: (id, error) => console.error('Ошибка воспроизведения звука победы:', error)
                });
                easterSound = new Howl({
                    src: ['sound/bonus.mp3'], // Звук для пасхального яйца
                    onload: () => console.log('Звук пасхального яйца загружен успешно'),
                    onloaderror: (id, error) => console.error('Ошибка загрузки звука пасхального яйца:', error),
                    onplayerror: (id, error) => console.error('Ошибка воспроизведения звука пасхального яйца:', error)
                });
                startSound = new Howl({
                    src: ['sound/start.mp3'], // Звук начала игры
                    volume: 0.5,
                    onload: () => console.log('Звук начала игры загружен успешно'),
                    onloaderror: (id, error) => console.error('Ошибка загрузки звука начала игры:', error),
                    onplayerror: (id, error) => console.error('Ошибка воспроизведения звука начала игры:', error)
                });
            } catch (e) {
                console.error('Ошибка при инициализации звуков:', e); // Обработка ошибок при настройке звуков
            }
        }

        // Начальная настройка: создает холст и инициализирует игру
        function setup() {
            let container = document.getElementById('game-container');
            let size = container.offsetWidth; // Получает ширину контейнера для квадратного холста
            let canvas = createCanvas(size, size); // Создает холст p5.js
            canvas.parent('game-container'); // Прикрепляет холст к контейнеру
            gameState = 'menu'; // Начинает в режиме меню
            score = 0; // Инициализирует счет
            timer = 0; // Инициализирует таймер
            // Загружает сохраненный прогресс
            document.getElementById('menu').style.display = 'block'; // Показывает меню
            // Обработчик изменения цвета шарика
            document.getElementById('ballColor').addEventListener('change', () => {
                if (player) player.color = document.getElementById('ballColor').value;
            });
            updateContinueButtonVisibility();
            loadSounds();
            }

function keyPressed() {
    keys[key] = false;
    if (keyCode === 27) {  // 27 = код Escape
        keyCode = 0;       // Предотвращаем стандартное поведение p5.js (остановка sketch)
        if (gameState === 'playing') {
            pauseAndSaveGame();
            showMenuFromGame();
            }
            return false;      // Предотвращаем дальнейшую обработку
            }
            keys[key] = true;
            updateContinueButtonVisibility();
            }

        // Адаптация холста при изменении размера окна
        function windowResized() {
            let size = document.getElementById('game-container').offsetWidth;
            resizeCanvas(size, size); // Изменяет размер холста
            if (maze) {
                cellSize = size / maze[0].length; // Пересчитывает размер ячейки
                player.r = cellSize / 4; // Обновляет радиус игрока
            }
        }

        // Генерация лабиринта с помощью рекурсивного алгоритма
        function generateMaze(size) {
            let maze = Array(size).fill().map(() => Array(size).fill(1)); // Создает массив, заполненный стенами (1)
            let stack = []; // Стек для алгоритма генерации
            // Внутренняя функция для вырезания проходов
            function carve(x, y) {
                maze[y][x] = 0; // Делает клетку проходом
                let directions = [[0, 2], [2, 0], [0, -2], [-2, 0]]; // Направления для проходов
                directions.sort(() => Math.random() - 0.5); // Случайный порядок
                for (let [dx, dy] of directions) {
                    let nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[ny][nx] === 1) {
                        if (Math.random() < 0.7 || stack.length < size) {
                            maze[y + dy / 2][x + dx / 2] = 0; // Убирает стену между клетками
                            maze[ny][nx] = 0; // Делает соседнюю клетку проходом
                            stack.push([nx, ny]); // Добавляет в стек
                        }
                    }
                }
            }
            maze[1][1] = 0; // Начальная точка - проход
            stack.push([1, 1]); // Начинает с точки (1, 1)
            while (stack.length > 0) {
                let [x, y] = stack[Math.floor(Math.random() * stack.length)]; // Выбирает случайную клетку
                let neighbors = [[0, 2], [2, 0], [0, -2], [-2, 0]].filter(([dx, dy]) => {
                    let nx = x + dx, ny = y + dy;
                    return nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[ny][nx] === 1;
                });
                if (neighbors.length > 0) {
                    let [dx, dy] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    let nx = x + dx, ny = y + dy;
                    maze[y + dy / 2][x + dx / 2] = 0; // Вырезает проход
                    maze[ny][nx] = 0; // Делает соседнюю клетку проходом
                    stack.push([nx, ny]); // Добавляет в стек
                } else {
                    stack.splice(stack.findIndex(pos => pos[0] === x && pos[1] === y), 1); // Удаляет клетку без соседей
                }
            }
            // Добавляет случайные проходы для разнообразия
            for (let i = 0; i < Math.floor(size * 0.2); i++) {
                let x = Math.floor(Math.random() * (size - 2)) + 1;
                let y = Math.floor(Math.random() * (size - 2)) + 1;
                if (maze[y][x] === 1 && Math.random() < 0.3) {
                    let directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    let [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                    let nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[ny][nx] === 0) {
                        maze[y][x] = 0; // Убирает стену для дополнительного прохода
                    }
                }
            }
            return maze; // Возвращает готовый лабиринт
        }

        // Вычисляет расстояние между двумя точками
        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Основной цикл рисования: обновляет игру каждый кадр
        function draw() {
            let currentTime = performance.now();
            let deltaTime = (currentTime - lastTime) / 1000; // Время между кадрами для плавности
            lastTime = currentTime;
            frameCount++; // Считает кадры
            if (currentTime - lastFpsTime >= 1000) {
                fps = frameCount; // Вычисляет FPS
                frameCount = 0;
                lastFpsTime = currentTime;
            }
            background(0); // Очищает холст черным фоном
            if (gameState === 'playing') { // Рисует и обновляет только в режиме игры
                drawMaze(); // Рисует лабиринт
                drawPlayer(); // Рисует игрока
                drawGoal(); // Рисует цель
                drawEasterEgg(); // Рисует пасхалку
                updateTimer(currentTime); // Обновляет таймер
                updatePlayer(deltaTime); // Обновляет позицию игрока
                checkWinCondition(); // Проверяет условие победы
                checkEasterEgg(); // Проверяет нахождение пасхалки
                updateUI(); // Обновляет интерфейс
            }
        }

        // Рисует лабиринт на холсте
        function drawMaze() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    fill(maze[y][x] === 1 ? 50 : 200); // Стены темные (50), проходы светлые (200)
                    rect(x * cellSize, y * cellSize, cellSize, cellSize); // Рисует ячейки
                }
            }
        }

        // Рисует игрока как круг с обводкой
        function drawPlayer() {
            fill(player.color || '#FF0000'); // Заполняет цветом игрока или красным по умолчанию
            ellipse(player.x * cellSize, player.y * cellSize, player.r * 2); // Рисует круг
            stroke(0); // Черная обводка
            strokeWeight(2);
            noFill();
            ellipse(player.x * cellSize, player.y * cellSize, player.r * 2); // Рисует контур
            noStroke();
        }

        // Рисует цель как зеленый круг
        function drawGoal() {
            fill(0, 255, 0); // Зеленый цвет
            ellipse(goal.x * cellSize, goal.y * cellSize, cellSize / 2); // Рисует цель
        }

        // Рисует пасхалку, если она не найдена
        function drawEasterEgg() {
            if (!easterEgg.found) {
                fill('#FFA500'); // Оранжевый цвет
                ellipse(easterEgg.x * cellSize, easterEgg.y * cellSize, cellSize / 2); // Рисует пасхалку
                stroke(0); // Черная обводка
                strokeWeight(2);
                noFill();
                ellipse(easterEgg.x * cellSize, easterEgg.y * cellSize, cellSize / 2); // Рисует контур
                noStroke();
            }
        }

        // Обновляет таймер игры
        function updateTimer(currentTime) {
            if (gameState === 'playing') {
                if (currentTime - lastTimerUpdate >= 1000) { // Увеличивает каждую секунду
                    timer += 1;
                    lastTimerUpdate = currentTime;
                }
            }
        }

        // Обновляет интерфейс: счет, время, имя, FPS
        function updateUI() {
            let ui = document.getElementById('ui');
            ui.innerHTML = `Счет: ${score}<br>Время: ${Math.floor(timer)}с<br>Игрок: ${currentUser || 'Гость'}<br>FPS: ${fps}`;
        }

        // Обновляет позицию игрока с учетом ввода и коллизий
        function updatePlayer(deltaTime) {
            let targetVelocity = { x: 0, y: 0 }; // Целевая скорость
            if (keys['ArrowLeft'] || keys['a']) targetVelocity.x -= SPEED; // Влево
            if (keys['ArrowRight'] || keys['d']) targetVelocity.x += SPEED; // Вправо
            if (keys['ArrowUp'] || keys['w']) targetVelocity.y -= SPEED; // Вверх
            if (keys['ArrowDown'] || keys['s']) targetVelocity.y += SPEED; // Вниз
            if (mouseControl.active && gameState === 'playing') { // Управление мышью
                let dx = (mouseControl.targetX - player.x * cellSize) / cellSize;
                let dy = (mouseControl.targetY - player.y * cellSize) / cellSize;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0.1) {
                    targetVelocity.x += (dx / distance) * SPEED; // Движение к курсору
                    targetVelocity.y += (dy / distance) * SPEED;
                }
            }
            // Плавное изменение скорости с учетом ускорения и времени
            velocity.x += (targetVelocity.x - velocity.x) * ACCELERATION * deltaTime;
            velocity.y += (targetVelocity.y - velocity.y) * ACCELERATION * deltaTime;
            // Применяет трение для замедления
            velocity.x *= Math.pow(0.5, FRICTION * deltaTime);
            velocity.y *= Math.pow(0.5, FRICTION * deltaTime);
            let nextX = player.x + velocity.x * deltaTime; // Новая позиция по X
            let nextY = player.y + velocity.y * deltaTime; // Новая позиция по Y
            if (!checkCollisionAt(nextX, player.y)) { // Проверяет коллизию по X
                player.x = nextX;
            } else {
                velocity.x = 0; // Сбрасывает скорость при столкновении
            }
            if (!checkCollisionAt(player.x, nextY)) { // Проверяет коллизию по Y
                player.y = nextY;
            } else {
                velocity.y = 0;
            }
        }

        // Обрабатывает нажатие мыши для управления
        function mousePressed() {
            if (gameState === 'playing') {
                mouseControl.active = true; // Активирует управление мышью
                mouseControl.targetX = mouseX; // Устанавливает цель по X
                mouseControl.targetY = mouseY; // Устанавливает цель по Y
            }
        }

        // Обновляет цель при перемещении мыши
        function mouseDragged() {
            if (gameState === 'playing') {
                mouseControl.targetX = mouseX;
                mouseControl.targetY = mouseY;
            }
        }

        // Деактивирует управление мышью при отпускании
        function mouseReleased() {
            mouseControl.active = false;
        }

        // Проверяет коллизии игрока со стенами
        function checkCollisionAt(nextX, nextY) {
            let margin = player.r / cellSize; // Отступ для учета размера игрока
            let px1 = nextX - margin, px2 = nextX + margin;
            let py1 = nextY - margin, py2 = nextY + margin;
            let x1 = Math.floor(px1), x2 = Math.floor(px2);
            let y1 = Math.floor(py1), y2 = Math.floor(py2);
            for (let y = Math.max(0, y1); y <= Math.min(maze.length - 1, y2); y++) {
                for (let x = Math.max(0, x1); x <= Math.min(maze[0].length - 1, x2); x++) {
                    if (maze[y][x] === 1) {
                        return true; // Столкновение со стеной
                    }
                }
            }
            // Проверяет выход за границы лабиринта
            return px1 < 0 || px2 > maze[0].length || py1 < 0 || py2 > maze.length;
        }

        // Проверяет условие победы
function checkWinCondition() {
    if (dist(player.x, player.y, goal.x, goal.y) < 0.3 && !gameWon) {
        gameWon = true;  // Устанавливаем флаг победы
        winGame();  
        saveGameOnWin();  
        pauseAndSaveGame();  // Это сохранит состояние, но мы сразу отметим, что продолжения нет
        hasActiveSave = false;
        localStorage.removeItem('savedGameState');  // Очищаем локальное сохранение (для гостей тоже)
        updateContinueButtonVisibility();  // Скрываем кнопку "Продолжить игру"
        showMenuFromGame();
    }
}

        // Проверяет нахождение пасхалки
        function checkEasterEgg() {
            if (!easterEgg.found && dist(player.x, player.y, easterEgg.x, easterEgg.y) < 0.3) {
                easterEgg.found = true; // Помечает пасхалку как найденную
                score += 50; // Добавляет бонусные очки
                if (easterSound) {
                    if (easterSound.state() === 'loaded') {
                        easterSound.play(); // Воспроизводит звук пасхалки
                        console.log('Звук пасхального яйца воспроизводится');
                    } else {
                        console.warn('Звук пасхального яйца не загружен');
                    }
                } else {
                    console.warn('Звук пасхального яйца не инициализирован');
                }
                 // Сохраняет прогресс
            }
        }

        // Обработка победы в игре
function winGame() {
    gameState = 'menu';
    noLoop(); // Останавливает рисование полностью
    score += difficulty === 'easy' ? 10 : difficulty === 'medium' ? 20 : 30;
    if (winSound && winSound.state() === 'loaded') winSound.play();
    if (bgMusic) bgMusic.stop();
    document.getElementById('menu').style.display = 'block';
    updateAuthUI(); // Обновляем меню
    loadLeaderboard();
    saveGameOnWin();
    background(0); // Очищает canvas
}
        // Запускает игру
        function startGame() {
            gameWon = false;  // Явно сбрасываем флаг победы
            hasActiveSave = false;                     // Очищаем флаг
            localStorage.removeItem('savedGameState'); // Очищаем локальное сохранение
            updateContinueButtonVisibility();          // Скрываем кнопку
            gameState = 'playing';  // Принудительно в режим игры
            if (startSound) {
                if (startSound.state() === 'loaded') {
                    startSound.play();
                    console.log('Звук начала игры воспроизводится');
                } else {
                    console.warn('Звук начала игры не загружен');
                }
            } else {
                console.warn('Звук начала игры не инициализирован');
            }

            difficulty = document.getElementById('difficulty').value; // Получает сложность
            let size = difficulty === 'easy' ? 10 : difficulty === 'medium' ? 15 : 20; // Устанавливает размер лабиринта
            maze = generateMaze(size); // Генерирует лабиринт
            cellSize = width / size; // Вычисляет размер ячейки
            player = { x: 1.5, y: 1.5, r: cellSize / 4, color: document.getElementById('ballColor').value }; // Инициализирует игрока
            let pathCells = []; // Список клеток для проходов
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    if (maze[y][x] === 0 && !(x === 1 && y === 1)) {
                        pathCells.push([x, y]); // Собирает клетки проходов
                    }
                }
            }
            let minDistance = size * 0.7; // Минимальное расстояние до цели
            let validGoalCells = pathCells.filter(([x, y]) => 
                x >= size * 0.6 && y >= size * 0.6 &&
                getDistance(1.5, 1.5, x + 0.5, y + 0.5) >= minDistance
            ); // Фильтрует клетки для цели
            if (validGoalCells.length === 0) {
                validGoalCells = pathCells.filter(([x, y]) => 
                    getDistance(1.5, 1.5, x + 0.5, y + 0.5) >= minDistance
                );
            }
            if (validGoalCells.length === 0) validGoalCells = pathCells; // Запасной вариант
            let [gx, gy] = validGoalCells[Math.floor(Math.random() * validGoalCells.length)];
            goal = { x: gx + 0.5, y: gy + 0.5 }; // Устанавливает цель
            let goalDistance = getDistance(1.5, 1.5, gx + 0.5, gy + 0.5); // Расстояние до цели
            let validEasterCells = pathCells.filter(([x, y]) => 
                getDistance(1.5, 1.5, x + 0.5, y + 0.5) < goalDistance * 0.8 &&
                getDistance(gx + 0.5, gy + 0.5, x + 0.5, y + 0.5) >= size * 0.3 &&
                !(x === gx && y === gy)
            ); // Фильтрует клетки для пасхалки
            if (validEasterCells.length === 0) validEasterCells = pathCells; // Запасной вариант
            let [ex, ey] = validEasterCells[Math.floor(Math.random() * validEasterCells.length)];
            easterEgg = { x: ex + 0.5, y: ey + 0.5, found: false }; // Устанавливает пасхалку
            timer = 0; // Сбрасывает таймер
            lastTimerUpdate = performance.now(); // Обновляет метку времени
            velocity = { x: 0, y: 0 }; // Сбрасывает скорость
            mouseControl = { active: false, targetX: 0, targetY: 0 }; // Сбрасывает управление мышью
            gameState = localStorage.getItem('tutorialCompleted') ? 'playing' : 'tutorial'; // Проверяет, нужно ли обучение
            document.getElementById('menu').style.display = 'none'; // Скрывает меню
            if (gameState === 'tutorial') {
                document.getElementById('tutorial').style.display = 'block'; // Показывает обучение
                showTutorial();
            } else {
                if (bgMusic) {
                    if (bgMusic.state() === 'loaded') {
                        bgMusic.play(); // Воспроизводит фоновую музыку
                        console.log('Фоновый звук воспроизводится');
                    } else {
                        console.warn('Фоновый звук не загружен');
                    }
                } else {
                    console.warn('Фоновый звук не инициализирован');
                }
                 // Сохраняет прогресс
            }

                updateAuthUI();  // На всякий случай обновляем UI
            if (accessToken) {
                loadLastSave();  // Подгружаем сложность и score с сервера
            }
            
            gameWon = false;

            document.getElementById('menu').style.display = 'none';

            loop(); // Возобновляет рисование при новой игре
            background(0); // Очищает перед новой игрой
        }

        function pauseAndSaveGame() {
    if (gameState !== 'playing') return;
    
    // Собираем полное состояние
    const state = {
        maze: maze,
        player: { x: player.x, y: player.y, color: player.color },
        goal: goal,
        easterEgg: easterEgg,
        timer: timer,
        score: score,
        difficulty: difficulty,
        gameWon: gameWon
    };
    
    // Сохраняем локально для всех
    localStorage.setItem('savedGameState', JSON.stringify(state));
    savedState = state;
    hasActiveSave = true;
    
    // Если авторизован — сохраняем на сервер
    if (accessToken) {
        fetch(`${API_URL}/game/session/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({
                score: score,
                difficulty: difficulty,
                time_played: Math.floor(timer),
                is_completed: gameWon,
                game_state: state  // Полное состояние
            })
        }).catch(e => console.log('Ошибка сохранения на сервер'));
    }
    
    gameState = 'menu';
    noLoop();  // Останавливаем рисование игры
}

        // Показывает шаги обучения
        function showTutorial() {
            let text = document.getElementById('tutorial-text');
            if (tutorialStep === 0) {
                text.innerHTML = 'Добро пожаловать в Лабиринт! Используйте WASD, стрелки, либо мышь, чтобы двигать шарик плавно.';
            } else if (tutorialStep === 1) {
                text.innerHTML = 'Доберитесь до зеленого шарика в лабиринте, чтобы победить. Избегайте темных стен!';
            } else if (tutorialStep === 2) {
                text.innerHTML = 'Найдите оранжевый шарик на пути, чтобы получить бонусные очки!';
            } else {
                localStorage.setItem('tutorialCompleted', 'true'); // Помечает обучение завершенным
                document.getElementById('tutorial').style.display = 'none'; // Скрывает обучение
                gameState = 'playing'; // Переходит в режим игры
                tutorialStep = 0; // Сбрасывает шаг
                if (bgMusic) {
                    if (bgMusic.state() === 'loaded') {
                        bgMusic.play(); // Воспроизводит фоновую музыку
                        console.log('Фоновый звук воспроизводится');
                    } else {
                        console.warn('Фоновый звук не загружен');
                    }
                } else {
                    console.warn('Фоновый звук не инициализирован');
                }
            }
        }

        // Переходит к следующему шагу обучения
        function nextTutorial() {
            tutorialStep++; // Увеличивает шаг
            showTutorial(); // Показывает следующий текст
        }

        updateAuthUI();
        loadLeaderboard();  // Чтобы лидерборд сразу показывался, если открыт таб

        // Показ таба
    function showMainTab(tab) {
    document.getElementById('settings-tab').style.display = 'none';
    document.getElementById('leaderboard-tab').style.display = 'none';
    document.getElementById(tab + '-tab').style.display = 'block';
    
    // Подсветка кнопок
    document.querySelectorAll('#menu button').forEach(btn => btn.style.fontWeight = 'normal');
    if (tabId === 'login-tab') document.getElementById('login-tab-btn').style.fontWeight = 'bold';
    if (tabId === 'game-tab') document.getElementById('game-tab-btn').style.fontWeight = 'bold';
    if (tabId === 'leaderboard-tab') document.getElementById('leaderboard-tab-btn').style.fontWeight = 'bold';
}

// Регистрация
async function register() {
    const username = document.getElementById('reg-username').value.trim();
    const password = document.getElementById('reg-password').value;
    if (!username || !password) return showAuthMessage('Заполните поля!');
    
    try {
        const response = await fetch(`${API_URL}/auth/register/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        const data = await response.json();
        if (response.ok) {
            showAuthMessage('Регистрация успешна! Теперь войдите.');
        } else {
            showAuthMessage(data.error || 'Ошибка регистрации');
        }
    } catch (e) {
        showAuthMessage('Нет связи с сервером');
    }
}

// Логин
async function login() {
    const username = document.getElementById('login-username').value.trim();
    const password = document.getElementById('login-password').value;
    if (!username || !password) return showAuthMessage('Заполните поля!');
    
    try {
        const response = await fetch(`${API_URL}/auth/token/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        const data = await response.json();
        if (response.ok) {
            accessToken = data.access;
            localStorage.setItem('accessToken', accessToken);
            currentUser = username;
            localStorage.setItem('currentUser', username);
            updateAuthUI();
            showAuthMessage('Вход успешный!');
            loadLastSave(); // Загружаем сохранение
        } else {
            showAuthMessage('Неверный логин или пароль');
        }
    } catch (e) {
        showAuthMessage('Нет связи с сервером');
    }
}

// Выход
function logout() {
    accessToken = null;
    currentUser = null;
    localStorage.removeItem('accessToken');
    localStorage.removeItem('currentUser');
    updateAuthUI();
    showTab('login-tab');
}

function showGameTab(tab) {
    document.getElementById('settings-section').style.display = 'none';
    document.getElementById('leaderboard-section').style.display = 'none';
    document.getElementById(tab + '-section').style.display = 'block';
    
    if (tab === 'leaderboard') {
        loadLeaderboard();
    }
}

// Обновление UI после авторизации
function updateAuthUI() {
    showMainGameMenu();
    loadLeaderboard();
    // Проверяем, есть ли сохранённое состояние при загрузке
    const saved = localStorage.getItem('savedGameState');
if (saved) {
    try {
        const state = JSON.parse(saved);
        if (state && !state.gameWon) {
            hasActiveSave = true;
        }
    } catch (e) {
        localStorage.removeItem('savedGameState');
    }
}
updateContinueButtonVisibility();
}

// Сообщения об ошибках
function showAuthMessage(msg) {
    document.getElementById('auth-message').textContent = msg;
}

// Загрузка лидерборда
async function loadLeaderboard() {
    document.getElementById('leaderboard-list').innerHTML = 'Загрузка...';
    try {
        const response = await fetch(`${API_URL}/game/leaderboard/`);
        const data = await response.json();
        const list = document.getElementById('leaderboard-list');
        list.innerHTML = '<ol style="text-align: left;">';
        data.forEach(entry => {
            list.innerHTML += `<li>${entry.username} — ${entry.score} очков (ранг ${entry.rank})</li>`;
        });
        list.innerHTML += '</ol>';
        if (data.length === 0) list.innerHTML = 'Лидерборд пуст';
    } catch (e) {
        document.getElementById('leaderboard-list').innerHTML = 'Ошибка загрузки лидерборда';
    }
}

// Загрузка последнего сохранения
async function loadLastSave() {
    if (!accessToken) {
        console.log('Не авторизован — пропускаем загрузку сохранения');
        return;
    }
    try {
        const response = await fetch(`${API_URL}/game/session/load/`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        if (response.ok) {
            const data = await response.json();
            if (data.score !== undefined) {
                score = data.score || 0;
                if (data.difficulty) {
                document.getElementById('difficulty').value = data.difficulty;
                }
            }
        } else if (response.status === 401) {
            console.log('Токен недействителен — перелогиньтесь');
        }
    } catch (e) {
        console.log('Ошибка сети при загрузке сохранения');
    }
}

async function loadSavedGameState() {
    let state = null;
    
    // Сначала пытаемся с сервера (если авторизован)
    if (accessToken) {
        try {
            const response = await fetch(`${API_URL}/game/session/load/`, {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            });
            if (response.ok) {
                const data = await response.json();
                if (data.game_state && !data.is_completed) {
                    state = data.game_state;
                    score = data.score || 0;
                    difficulty = data.difficulty || 'medium';
                }
            }
        } catch (e) {}
    }
    
    // Если нет с сервера или гость — из localStorage
    if (!state) {
        const saved = localStorage.getItem('savedGameState');
        if (saved) {
            state = JSON.parse(saved);
        }
    }
    
    if (state && !state.gameWon) {
        // Восстанавливаем состояние
        maze = state.maze;
        player = { ...state.player, r: cellSize / 4 };
        goal = state.goal;
        easterEgg = state.easterEgg;
        timer = state.timer;
        score = state.score;
        difficulty = state.difficulty;
        document.getElementById('difficulty').value = difficulty;
        document.getElementById('ballColor').value = player.color;
        
        hasActiveSave = true;
        gameWon = false;
        gameState = 'playing';
        return true;
    }
    hasActiveSave = false;
    updateContinueButtonVisibility();
    return false;
}

// Сохранение сессии при победе (вызови эту функцию в месте, где игрок достигает цели)
async function saveGameOnWin() {
    if (!accessToken) return; // Только если авторизован
    
    const sessionData = {
        score: score,
        difficulty: difficulty,
        time_played: Math.floor(timer),
        is_completed: true,
        game_state: {} // Можно добавить JSON состояния, если нужно
    };
    
    try {
        await fetch(`${API_URL}/game/session/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify(sessionData)
        });
        loadLeaderboard(); // Обновляем лидерборд
    } catch (e) {
        console.log('Не удалось сохранить на сервер');
    }
}
async function resetGameProgress() {
    if (!confirm('Полный сброс прогресса (очки = 0 на сервере и в лидерборде)?')) return;
    
    score = 0;
    
    if (accessToken) {
        const sessionData = {
            score: 0,
            difficulty: difficulty,
            time_played: 0,
            is_completed: true, // Важно: true, чтобы backend взял 0 в max(score)
            game_state: {}
        };
        
        try {
            await fetch(`${API_URL}/game/session/save/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${accessToken}`
                },
                body: JSON.stringify(sessionData)
            });
            loadLeaderboard(); // Обновляем лидерборд сразу
            alert('Прогресс полностью сброшен (очки = 0 в лидерборде)!');
        } catch (e) {
            alert('Ошибка сброса на сервере');
        }
    } else {
        alert('Прогресс сброшен локально');
    }
}

function showAuth() {
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('auth-panel').style.display = 'block';
}

function backToStart() {
    document.getElementById('auth-panel').style.display = 'none';
    document.getElementById('start-menu').style.display = 'block';
}

function playAsGuest() {
    currentUser = 'Гость';
    accessToken = null;
    localStorage.setItem('currentUser', currentUser);
    showMainGameMenu();
}

function showMainGameMenu() {
    if (!accessToken) {
    }
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('auth-panel').style.display = 'none';
    document.getElementById('main-game-menu').style.display = 'block';
    document.getElementById('username-display').textContent = currentUser || 'Гость';
    loadLeaderboard();
    updateContinueButtonVisibility();
}

function backToMainMenu() {
    document.getElementById('settings-panel').style.display = 'none';
    document.getElementById('leaderboard-panel').style.display = 'none';
    document.getElementById('friends-panel').style.display = 'none';
    document.getElementById('profile-panel').style.display = 'none';
    document.getElementById('main-game-menu').style.display = 'block';
}

function showSettings() {
    document.getElementById('main-game-menu').style.display = 'none';
    document.getElementById('settings-panel').style.display = 'block';
}

function showLeaderboard() {
    document.getElementById('main-game-menu').style.display = 'none';
    document.getElementById('leaderboard-panel').style.display = 'block';
    loadLeaderboard();
}

function startNewGame() {
    hasActiveSave = false;
    localStorage.removeItem('savedGameState');
    updateContinueButtonVisibility();
    startGame(); // Просто запускаем новую игру
}

async function continueGame() {
    await loadSavedGameState();  // Пытаемся загрузить сохранённое состояние
    
    if (hasActiveSave) {
        cellSize = width / maze[0].length;
        player.r = cellSize / 4;
        velocity = { x: 0, y: 0 };
        lastTimerUpdate = performance.now();
        document.getElementById('menu').style.display = 'none';
        if (bgMusic && bgMusic.state() === 'loaded') bgMusic.play();
        loop();
    } else {
        startNewGame();  // Если нет сохранения — просто новая игра
    }
}

function updateContinueButtonVisibility() {
    // Находим кнопку "Продолжить игру" по её onclick
    const continueBtn = document.querySelector('#main-game-menu button[onclick="continueGame()"]');
    if (continueBtn) {
        if (hasActiveSave) {
            continueBtn.style.display = 'block';  // Показываем, если есть сохранение
        } else {
            continueBtn.style.display = 'none';   // Скрываем, если нет
        }
    }
}

function keyPressed() {
    // Не блокируем клавиатуру в меню/регистрации — ввод в <input> работает
    if (gameState !== 'playing') {
        return;  // Полностью пропускаем обработку
    }

    // Esc для паузы
    if (keyCode === 27) {  // Escape
        keyCode = 0;  // Отключаем стандартное поведение p5.js
        pauseAndSaveGame();
        showMenuFromGame();
        return false;  // Блокируем только Esc
    }

    // Регистрируем клавиши в lowercase для WASD
    const lowerKey = key.toLowerCase();
    keys[lowerKey] = true;

    // Дополнительно для стрелок (если ваш код в draw() использует keyCode)
    if (keyCode === LEFT_ARROW) keys['a'] = true;
    if (keyCode === RIGHT_ARROW) keys['d'] = true;
    if (keyCode === UP_ARROW) keys['w'] = true;
    if (keyCode === DOWN_ARROW) keys['s'] = true;

    // Блокируем скролл страницы только для игровых клавиш
    if ([32, 37, 38, 39, 40].includes(keyCode) || ['w', 'a', 's', 'd'].includes(lowerKey)) {
        return false;
    }
}

function keyReleased() {
    if (gameState !== 'playing') {
        return;
    }

    const lowerKey = key.toLowerCase();
    keys[lowerKey] = false;

    // Для стрелок
    if (keyCode === LEFT_ARROW) keys['a'] = false;
    if (keyCode === RIGHT_ARROW) keys['d'] = false;
    if (keyCode === UP_ARROW) keys['w'] = false;
    if (keyCode === DOWN_ARROW) keys['s'] = false;
}

function pauseAndSaveGame() {
    if (gameState !== 'playing') return;
    
    const state = {
        maze: maze,
        player: { x: player.x, y: player.y, color: player.color },
        goal: goal,
        easterEgg: easterEgg,
        timer: timer,
        score: score,
        difficulty: difficulty,
        gameWon: gameWon
    };
    
    localStorage.setItem('savedGameState', JSON.stringify(state));
    hasActiveSave = true;
    
    // Если авторизован — сохраняем на сервер (необязательно для паузы, но можно)
    if (accessToken) {
        fetch(`${API_URL}/game/session/save/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({
                score: score,
                difficulty: difficulty,
                time_played: Math.floor(timer),
                is_completed: false,
                game_state: state
            })
        }).catch(e => console.log('Ошибка сохранения на сервер при паузе'));
    }
    
    gameState = 'menu';
    noLoop();  // Останавливаем игру
    updateContinueButtonVisibility();
}

function showMenuFromGame() {
    document.getElementById('menu').style.display = 'block';
    document.getElementById('main-game-menu').style.display = 'block';
    updateContinueButtonVisibility();
}

function logout() {
    accessToken = null;
    currentUser = null;
    localStorage.removeItem('accessToken');
    localStorage.removeItem('currentUser');
    document.getElementById('main-game-menu').style.display = 'none';
    document.getElementById('start-menu').style.display = 'block';
}

function changeAccount() {
    if (confirm('Сменить аккаунт? Вы вернётесь в стартовое меню.')) {
        accessToken = null;
        currentUser = null;
        localStorage.removeItem('accessToken');
        localStorage.removeItem('currentUser');
        document.getElementById('main-game-menu').style.display = 'none';
        document.getElementById('start-menu').style.display = 'block';
    }
}

function showProfile() {
    document.getElementById('main-game-menu').style.display = 'none';
    document.getElementById('profile-panel').style.display = 'block';
    loadProfile(); // Загружаем текущий профиль
}

async function loadProfile() {
    if (!accessToken) {
        document.getElementById('profile-message').textContent = 'Войдите в аккаунт';
        return;
    }
    try {
        const response = await fetch(`${API_URL}/auth/profile/`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        if (response.ok) {
            const data = await response.json();
            document.getElementById('profile-username').textContent = data.user.username;
            document.getElementById('profile-bio').value = data.bio || '';
            document.getElementById('profile-dob').value = data.date_of_birth || '';
            
            // Полный URL аватара с кэш-бустером
            let avatarUrl = 'https://via.placeholder.com/150?text=Нет+аватара'; // Плейсхолдер по умолчанию
            if (data.avatar) {
                avatarUrl = `http://127.0.0.1:8001${data.avatar}?t=${new Date().getTime()}`; // Замени 8001 на 8000 если порт другой
            }
            document.getElementById('profile-avatar').src = avatarUrl;
        } else {
            document.getElementById('profile-message').textContent = 'Ошибка загрузки профиля';
        }
    } catch (e) {
        document.getElementById('profile-message').textContent = 'Нет связи с сервером';
    }
}

async function saveProfile() {
    if (!accessToken) {
        document.getElementById('profile-message').textContent = 'Войдите в аккаунт';
        return;
    }
    const bio = document.getElementById('profile-bio').value;
    const dob = document.getElementById('profile-dob').value;
    const avatarFile = document.getElementById('profile-avatar-input').files[0];

    const formData = new FormData();
    formData.append('bio', bio);
    if (dob) formData.append('date_of_birth', dob);
    if (avatarFile) formData.append('avatar', avatarFile);

    try {
        const response = await fetch(`${API_URL}/auth/profile/update/`, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${accessToken}`
                // НЕ ставим 'Content-Type' — браузер сам поставит multipart с boundary
            },
            body: formData
        });
        const data = await response.json();
        if (response.ok) {
            document.getElementById('profile-message').textContent = 'Профиль сохранён!';
            loadProfile(); // Обновляем отображение (новый аватар)
        } else {
            document.getElementById('profile-message').textContent = data.detail || 'Ошибка сохранения';
        }
    } catch (e) {
        document.getElementById('profile-message').textContent = 'Нет связи с сервером';
    }
}

function showFriends() {
    document.getElementById('main-game-menu').style.display = 'none';
    document.getElementById('friends-panel').style.display = 'block';
    loadFriendsData(); // Загружаем список друзей при открытии
}

async function loadFriends() {
    document.getElementById('friends-message').textContent = 'Загрузка...';
    if (!accessToken) {
        document.getElementById('friends-message').textContent = 'Войдите в аккаунт';
        document.getElementById('friends-list').innerHTML = '';
        return;
    }
    try {
        const response = await fetch(`${API_URL}/game/friends/`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        if (response.ok) {
            const friends = await response.json();
            const list = document.getElementById('friends-list');
            list.innerHTML = ''; // Очищаем полностью
            if (friends.length === 0) {
                list.innerHTML = '<p style="color: #aaa; text-align: center;">Нет друзей</p>';
            } else {
                friends.forEach(friend => {
                    list.innerHTML += `
                        <div style="background: rgba(255,255,255,0.1); padding: 15px; margin: 10px 0; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${friend.username}</strong><br>
                                ${friend.max_score || 0} очков (ранг ${friend.rank || '-'})
                            </div>
                            <button onclick="removeFriend('${friend.username}')" style="background: #f44336; color: white; padding: 10px; border-radius: 5px;">Удалить</button>
                        </div>`;
                });
            }
            document.getElementById('friends-message').textContent = '';
        } else {
            document.getElementById('friends-message').textContent = 'Ошибка загрузки друзей';
        }
    } catch (e) {
        document.getElementById('friends-message').textContent = 'Нет связи с сервером';
    }
}

async function loadIncomingRequests() {
    const list = document.getElementById('incoming-requests-list');
    list.innerHTML = '<p>Загрузка...</p>';
    
    if (!accessToken) {
        list.innerHTML = '<p style="color: #aaa;">Войдите в аккаунт</p>';
        return;
    }
    
    try {
        const response = await fetch(`${API_URL}/game/friends/requests/incoming/`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        if (response.ok) {
            const requests = await response.json();
            if (requests.length === 0) {
                list.innerHTML = '<p style="color: #aaa; text-align: center;">Нет входящих заявок</p>';
            } else {
                list.innerHTML = '';
                requests.forEach(req => {
                    list.innerHTML += `
                        <div style="background: rgba(255,255,255,0.1); padding: 15px; margin: 10px 0; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${req.username}</strong><br>
                                ${req.max_score || 0} очков (ранг ${req.rank || '-'})
                            </div>
                            <div>
                                <button onclick="acceptFriendRequest('${req.username}')" style="background: #4caf50; color: white; padding: 8px; margin: 5px; border-radius: 5px;">Принять</button>
                                <button onclick="rejectFriendRequest('${req.username}')" style="background: #f44336; color: white; padding: 8px; margin: 5px; border-radius: 5px;">Отклонить</button>
                            </div>
                        </div>`;
                });
            }
        } else {
            list.innerHTML = '<p style="color: red;">Ошибка загрузки заявок</p>';
        }
    } catch (e) {
        list.innerHTML = '<p style="color: red;">Нет связи с сервером</p>';
    }
}

async function acceptFriendRequest(username) {
    await handleFriendRequest(username, 'accept');
}

async function rejectFriendRequest(username) {
    await handleFriendRequest(username, 'reject');
}

async function handleFriendRequest(username, action) {
    try {
        const response = await fetch(`${API_URL}/game/friends/${action}/`, {  // /accept/ или /reject/
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({ username })
        });
        if (response.ok) {
            loadFriendsData();  // Обновляем всё
        }
    } catch (e) {
        // Игнорируем ошибку
    }
}

// Общая функция загрузки друзей + заявок
async function loadFriendsData() {
    await loadFriends();         // Текущая функция для принятых друзей
    await loadIncomingRequests(); // Новая для входящих заявок
}

async function sendFriendRequest() {
    const username = document.getElementById('friend-username').value.trim();
    if (!username) {
        document.getElementById('friends-message').textContent = 'Введите username';
        return;
    }
    if (!accessToken) {
        document.getElementById('friends-message').textContent = 'Войдите в аккаунт';
        return;
    }
    
    try {
        const response = await fetch(`${API_URL}/game/friends/add/`, {  // Или /game/friends/request/ если изменил на бэкенде
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({ username })
        });
        const data = await response.json();
        if (response.ok) {
            const msg = document.getElementById('friends-message');
            msg.textContent = 'Заявка отправлена!';
            msg.style.color = 'green';
            setTimeout(() => { msg.textContent = ''; }, 3000);
            document.getElementById('friend-username').value = '';
            loadFriendsData();  // Обновляем всё
        } else {
            document.getElementById('friends-message').textContent = data.error || 'Ошибка (уже друг/заявка отправлена)';
            document.getElementById('friends-message').style.color = 'red';
        }
    } catch (e) {
        document.getElementById('friends-message').textContent = 'Нет связи с сервером';
    }
}

async function removeFriend(username) {
    if (!confirm(`Удалить ${username} из друзей?`)) return;
    
    try {
        const response = await fetch(`${API_URL}/game/friends/remove/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({ username })
        });
        if (response.ok) {
            loadFriendsData();  // Обновляем список друзей + заявки после удаления
        } else {
            alert('Ошибка удаления друга');
        }
    } catch (e) {
        alert('Нет связи с сервером');
    }
}

    </script>
</body>
</html>